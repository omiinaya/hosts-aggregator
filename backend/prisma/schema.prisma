generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Source {
  id                 String              @id @default(cuid())
  name               String              @unique
  url                String?
  filePath           String?
  type               String
  enabled            Boolean             @default(true)
  metadata           String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  format             String?             @default("auto")
  aggregationSources AggregationSource[]
  contentCache       SourceContent?
  fetchLogs          SourceFetchLog[]
  hosts              HostEntry[]

  @@index([enabled])
  @@index([type])
  @@map("sources")
}

model HostEntry {
  id               String              @id @default(cuid())
  domain           String
  normalized       String
  entryType        String              @default("block")
  enabled          Boolean             @default(true)
  firstSeen        DateTime            @default(now())
  lastSeen         DateTime            @updatedAt
  occurrenceCount  Int                 @default(1)
  sourceId         String?
  source           Source?             @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  aggregationHosts AggregationHost[]
  sourceMappings   SourceHostMapping[]

  @@unique([domain, sourceId])
  @@index([domain])
  @@index([normalized])
  @@index([entryType])
  @@index([enabled])
  @@index([lastSeen])
  @@index([sourceId])
  @@index([sourceId, domain])
  @@index([normalized, sourceId])
  @@map("host_entries")
}

model SourceHostMapping {
  id          String    @id @default(cuid())
  sourceId    String
  hostEntryId String
  lineNumber  Int?
  rawLine     String?
  comment     String?
  enabled     Boolean   @default(true)
  firstSeen   DateTime  @default(now())
  lastSeen    DateTime  @updatedAt
  hostEntry   HostEntry @relation(fields: [hostEntryId], references: [id], onDelete: Cascade)

  @@unique([sourceId, hostEntryId])
  @@index([sourceId])
  @@index([hostEntryId])
  @@index([enabled])
  @@index([firstSeen])
  @@map("source_host_mappings")
}

model SourceContent {
  id          String   @id @default(cuid())
  sourceId    String   @unique
  content     String
  contentHash String
  lineCount   Int      @default(0)
  entryCount  Int      @default(0)
  fetchedAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  format      String?
  source      Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([contentHash])
  @@index([fetchedAt])
  @@map("source_contents")
}

model SourceFetchLog {
  id             String   @id @default(cuid())
  sourceId       String
  status         String
  httpStatus     Int?
  errorMessage   String?
  responseTimeMs Int?
  contentChanged Boolean  @default(false)
  contentId      String?
  fetchedAt      DateTime @default(now())
  source         Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@index([status])
  @@index([fetchedAt])
  @@map("source_fetch_logs")
}

model AggregationResult {
  id                String              @id @default(cuid())
  timestamp         DateTime            @default(now())
  totalSources      Int
  successfulSources Int                 @default(0)
  failedSources     Int                 @default(0)
  totalEntries      Int
  uniqueEntries     Int
  duplicatesRemoved Int
  allowEntries      Int                 @default(0)
  blockEntries      Int                 @default(0)
  processingTimeMs  Int
  triggeredBy       String              @default("manual")
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  hosts             AggregationHost[]
  sources           AggregationSource[]

  @@index([timestamp])
  @@index([createdAt])
  @@map("aggregation_results")
}

model AggregationSource {
  id                       String            @id @default(cuid())
  aggregationResultId      String
  sourceId                 String
  entriesContributed       Int               @default(0)
  uniqueDomainsContributed Int               @default(0)
  fetchStatus              String
  fetchDurationMs          Int?
  source                   Source            @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  aggregationResult        AggregationResult @relation(fields: [aggregationResultId], references: [id], onDelete: Cascade)

  @@unique([aggregationResultId, sourceId])
  @@index([aggregationResultId])
  @@index([sourceId])
  @@map("aggregation_sources")
}

model AggregationHost {
  id                  String            @id @default(cuid())
  aggregationResultId String
  hostEntryId         String
  sourceIds           String
  primarySourceId     String
  hostEntry           HostEntry         @relation(fields: [hostEntryId], references: [id], onDelete: Cascade)
  aggregationResult   AggregationResult @relation(fields: [aggregationResultId], references: [id], onDelete: Cascade)

  @@unique([aggregationResultId, hostEntryId])
  @@index([aggregationResultId])
  @@index([hostEntryId])
  @@index([primarySourceId])
  @@map("aggregation_hosts")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String
  role          String    @default("viewer")
  apiKey        String?   @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?

  @@index([email])
  @@index([role])
  @@index([apiKey])
  @@map("users")
}
